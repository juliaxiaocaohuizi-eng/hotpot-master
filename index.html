<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hot Pot Master: Progressive Memory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&display=swap');

        :root {
            --pot-gold: #d4af37;
            --spicy-red: #b30000;
            --clear-gold: #fdf5e6;
            --tomato-orange: #ff6347;
            --steam-white: rgba(255, 255, 255, 0.4);
        }

        body {
            background-color: #1a0f0f;
            color: #ecf0f1;
            font-family: 'ZCOOL XiaoWei', 'Segoe UI', serif;
            overflow: hidden;
            touch-action: none;
        }

        .hotpot-container {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 10px auto;
        }

        .pot-outer {
            width: 100%;
            height: 100%;
            background: #222;
            border: 12px solid #8b0000;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
            z-index: 10;
        }

        .broth-section {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transition: clip-path 0.5s ease;
        }

        .spicy-side {
            background: radial-gradient(circle at 30% 30%, #ff4500, #800000);
            clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%);
        }

        .clear-side {
            background: radial-gradient(circle at 70% 30%, #fff9e6, #e6cc80);
            clip-path: polygon(50% 0, 100% 0, 100% 100%, 50% 100%);
        }

        .pot-outer.triple .spicy-side {
            clip-path: polygon(50% 50%, 0% 78.9%, 0% 0%, 50% 0%);
        }
        .pot-outer.triple .clear-side {
            clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 78.9%);
        }
        .tomato-side {
            background: radial-gradient(circle at 50% 80%, #ff7f50, #cc4400);
            display: none;
        }
        .pot-outer.triple .tomato-side {
            display: block;
            clip-path: polygon(50% 50%, 100% 78.9%, 100% 100%, 0% 100%, 0% 78.9%);
        }

        .pot-divider {
            position: absolute;
            left: 50%;
            top: 50%;
            height: 160px;
            width: 8px;
            background: #8b0000;
            transform-origin: top center;
            z-index: 15;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        .mode-btn {
            background: linear-gradient(to bottom, #8b0000, #500);
            border: 2px solid #d4af37;
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 999px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.2s;
            min-width: 200px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .mode-btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .mode-btn:active { transform: scale(0.95); }
        .mode-btn.secondary { background: linear-gradient(to bottom, #444, #222); border-color: #888; }

        .stream-controls {
            display: none;
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            gap: 1rem;
            z-index: 60;
            width: 100%;
            justify-content: center;
        }
        
        .stream-btn {
            width: 130px;
            height: 130px;
            border-radius: 50%;
            font-weight: bold;
            font-size: 1.1rem;
            text-transform: uppercase;
            border: 4px solid rgba(255,255,255,0.2);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            transition: transform 0.1s, background-color 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .stream-btn:active { transform: scale(0.95); }
        .stream-btn.clicked { filter: brightness(1.3); border-color: white; transform: scale(0.95); }
        
        .btn-no { background: #8b0000; color: #ffcccc; }
        .btn-yes { background: #2d5a27; color: #ccffcc; }

        .skewer-wrapper {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 60;
            pointer-events: none;
        }
        
        .skewer-stick {
            width: 8px;
            height: 250px;
            background: linear-gradient(90deg, #8b5a2b, #a0522d, #8b5a2b);
            border-radius: 4px;
            box-shadow: 2px 5px 10px rgba(0,0,0,0.5);
            margin-top: -30px;
            z-index: 1;
        }
        
        .skewer-emoji {
            font-size: 4.5rem;
            z-index: 2;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
        }

        .skewer-wrapper.dipped {
            z-index: 40;
            filter: brightness(0.85);
        }
        
        .skewer-wrapper.sunk {
            transform: translate(-50%, 150%) !important;
            opacity: 0;
            transition: all 0.8s ease-in;
        }

        .ingredient {
            position: absolute;
            cursor: pointer;
            transition: transform 0.1s;
            user-select: none;
            z-index: 50; 
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .ingredient-icon {
            font-size: 2.5rem;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
            pointer-events: none;
        }

        .cooking-timer {
            font-size: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            margin-top: -5px;
            border: 1px solid rgba(255,255,255,0.2);
            pointer-events: none;
        }

        .steam {
            position: absolute;
            background: var(--steam-white);
            border-radius: 50%;
            filter: blur(12px);
            pointer-events: none;
            animation: rise 2.5s infinite linear;
            z-index: 30;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(20, 10, 10, 0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
        }

        #memory-phase { display: none; }
        #game-over { display: none; }
        #home-screen { z-index: 200; } 

        .recipe-card {
            background: #2d1b1b;
            border: 2px solid #d4af37;
            border-radius: 1rem;
            padding: 1rem;
            width: 100%;
            max-width: 320px;
        }

        .ingredient-source {
            touch-action: none;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s;
        }
        .ingredient-source:active { cursor: grabbing; transform: scale(1.1); }

        .drag-proxy {
            position: fixed;
            pointer-events: none;
            font-size: 2.5rem;
            z-index: 1000;
            display: none;
        }

        .garnish { position: absolute; opacity: 0.5; pointer-events: none; }
        .chili-flake { width: 8px; height: 12px; background: #600; border-radius: 50% 20% 50% 20%; }
        .scallion { width: 10px; height: 10px; border: 2px solid #2d5a27; background: #4a8c42; border-radius: 50%; }
        .tomato-piece { width: 15px; height: 15px; background: #ff4d4d; border: 1px solid #900; border-radius: 40% 60% 30% 70%; }

        .used-stick {
            position: absolute;
            width: 6px;
            height: 60px;
            background: linear-gradient(90deg, #8b5a2b, #5e3b1f);
            border-radius: 3px;
            z-index: 20;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            transition: opacity 1.5s;
        }

        @keyframes rise {
            0% { transform: translateY(0) scale(1); opacity: 0; }
            100% { transform: translateY(-120px) scale(2); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-start min-h-screen p-4 overflow-hidden">

    <!-- In-game Controls -->
    <div id="ingame-controls" class="absolute top-2 w-full flex justify-between px-2 z-50 pointer-events-none max-w-4xl mx-auto">
        <button id="ingame-home-btn" class="pointer-events-auto bg-black/40 text-yellow-500 hover:bg-black/60 hover:text-white p-2 rounded-full border border-yellow-900/50 backdrop-blur-sm transition-all shadow-lg active:scale-90" aria-label="Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <button id="ingame-restart-btn" class="pointer-events-auto bg-black/40 text-yellow-500 hover:bg-black/60 hover:text-white p-2 rounded-full border border-yellow-900/50 backdrop-blur-sm transition-all shadow-lg active:scale-90" aria-label="Restart">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        </button>
    </div>

    <div class="text-center mt-2 mb-2">
        <h1 class="text-3xl font-bold text-yellow-500 tracking-widest" style="text-shadow: 2px 2px #000;">MEMORY POT</h1>
        <p id="phase-label" class="text-xs text-red-400 font-bold uppercase tracking-widest">Wait for Recipe...</p>
    </div>

    <div class="flex gap-4 mb-4 bg-black/40 px-6 py-1 rounded-full border border-yellow-900/50">
        <div class="text-center">
            <span class="block text-[10px] uppercase text-yellow-600">Level</span>
            <span id="level" class="text-xl font-bold text-white">1</span>
        </div>
        <div class="text-center px-4 border-l border-r border-yellow-900/30">
            <span class="block text-[10px] uppercase text-yellow-600">Time</span>
            <span id="level-timer" class="text-xl font-bold text-red-400">00</span>
        </div>
        <div class="text-center">
            <span class="block text-[10px] uppercase text-yellow-600">Lives</span>
            <div id="lives" class="text-lg">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
    </div>

    <!-- N-Back Countdown Bar -->
    <div id="stream-countdown" class="hidden fixed top-24 left-1/2 -translate-x-1/2 w-64 h-3 bg-gray-800 rounded-full overflow-hidden z-50 border border-yellow-900/50 shadow-[0_0_15px_rgba(212,175,55,0.3)]">
        <div id="stream-countdown-fill" class="h-full bg-gradient-to-r from-yellow-600 to-yellow-400 w-full origin-left"></div>
    </div>

    <div class="hotpot-container" id="pot-area">
        <div id="main-pot" class="pot-outer">
            <div class="broth-section spicy-side">
                <div class="garnish chili-flake" style="top:25%; left:25%"></div>
                <div class="garnish chili-flake" style="top:45%; left:30%"></div>
            </div>
            <div class="broth-section clear-side">
                <div class="garnish scallion" style="top:25%; right:25%"></div>
                <div class="garnish scallion" style="top:45%; right:30%"></div>
            </div>
            <div class="broth-section tomato-side">
                <div class="garnish tomato-piece" style="bottom:15%; left:45%"></div>
                <div class="garnish tomato-piece" style="bottom:25%; left:50%"></div>
            </div>

            <!-- Divider logic -->
            <div id="div-0" class="pot-divider" style="transform: translateX(-50%) rotate(180deg); display:none;"></div>
            <div id="div-120" class="pot-divider" style="transform: translateX(-50%) rotate(300deg); display:none;"></div>
            <div id="div-240" class="pot-divider" style="transform: translateX(-50%) rotate(60deg); display:none;"></div>
            <div id="divider-center" class="pot-divider" style="transform: translateX(-50%) rotate(0deg); height: 320px; top: 0;"></div>
        </div>
        
        <!-- Layer for stream mode animations -->
        <div id="stream-display-area" class="absolute inset-0 pointer-events-none"></div>
    </div>

    <!-- Home Screen -->
    <div id="home-screen" class="overlay">
        <h1 class="text-5xl text-yellow-500 mb-2 font-bold tracking-widest" style="text-shadow: 4px 4px #000;">HOT POT MASTER</h1>
        <p class="text-xl text-gray-300 mb-8 italic tracking-wide">Memory & Speed Challenge</p>
        
        <div class="bg-black/60 p-6 rounded-xl border border-yellow-900/50 mb-8 max-w-xs text-left backdrop-blur-sm shadow-2xl">
            <p class="text-yellow-100 mb-3 text-lg">ü•¢ <span class="text-yellow-500 font-bold">Classic:</span> Cook items from memory.</p>
            <p class="text-yellow-100 mb-3 text-lg">üî• <span class="text-yellow-500 font-bold">N-Back:</span> Cook previous round items!</p>
            <p class="text-yellow-100 text-lg">üéß <span class="text-yellow-500 font-bold">Stream:</span> Dual N-Back. Visual & Audio!</p>
        </div>

        <div class="flex flex-col gap-4">
            <button id="start-classic-btn" class="mode-btn">Classic Feast</button>
            <button id="start-nback-btn" class="mode-btn secondary">N-Back Rounds</button>
             <button id="start-stream-btn" class="mode-btn" style="background: linear-gradient(to bottom, #d4af37, #8a7018); border-color: #ffeeb0; color: #000;">
                Dual Stream
            </button>
        </div>
    </div>

    <!-- Stream Mode UI Controls (Original - Not used in Dual but kept for structure if needed) -->
    <div id="stream-controls" class="stream-controls">
        <button id="btn-no" class="stream-btn btn-no">NO<br><span class="text-sm font-normal opacity-70">Different</span></button>
        <button id="btn-yes" class="stream-btn btn-yes">YES<br><span class="text-sm font-normal opacity-70">Match</span></button>
    </div>

    <!-- Dual Stream UI Controls -->
    <div id="dual-controls" class="stream-controls" style="display: none;">
        <button id="btn-visual-match" class="stream-btn" style="background: #e67e22; color: white; border-color: #f39c12;">
            <span class="text-3xl">üëÅÔ∏è</span>
            <span>VISUAL</span>
        </button>
        <button id="btn-audio-match" class="stream-btn" style="background: #2980b9; color: white; border-color: #3498db;">
            <span class="text-3xl">üëÇ</span>
            <span>AUDIO</span>
        </button>
    </div>

    <!-- Recipe/Memory Phase -->
    <div id="memory-phase" class="overlay">
        <h2 class="text-xl text-yellow-500 mb-1 font-bold tracking-widest">ROUND <span id="round-num">1</span></h2>
        <h3 class="text-2xl text-white mb-2 font-bold" id="memory-title">MEMORIZE THE SIDES</h3>
        <p class="text-sm text-yellow-300 mb-4 animate-pulse hidden" id="nback-hint">Memorize this for NEXT round! Cook PREVIOUS!</p>

        <div class="recipe-card mb-6">
            <div id="recipe-grid" class="grid grid-cols-2 gap-4">
                <div class="text-left border-r border-yellow-900/50 pr-2">
                    <p class="text-red-500 font-bold text-[10px] uppercase mb-1">üî• Spicy</p>
                    <div id="spicy-recipe-list" class="flex flex-wrap gap-1 text-2xl"></div>
                </div>
                <div class="text-left pl-2">
                    <p class="text-blue-300 font-bold text-[10px] uppercase mb-1">üç≤ Clear</p>
                    <div id="clear-recipe-list" class="flex flex-wrap gap-1 text-2xl"></div>
                </div>
                <div id="tomato-recipe-box" class="text-left col-span-2 mt-2 pt-2 border-t border-yellow-900/50 hidden">
                    <p class="text-orange-400 font-bold text-[10px] uppercase mb-1 text-center">üçÖ Tomato</p>
                    <div id="tomato-recipe-list" class="flex flex-wrap justify-center gap-2 text-3xl"></div>
                </div>
            </div>
        </div>
        <div class="w-full bg-gray-800 h-2 rounded-full overflow-hidden max-w-[200px]">
            <div id="memory-timer-bar" class="bg-yellow-500 h-full w-full"></div>
        </div>
        <p class="text-[10px] text-gray-500 mt-2 uppercase tracking-widest" id="timer-text">Vanish in 5s</p>
    </div>

    <!-- Ingredient Palette -->
    <div class="mt-auto mb-6 grid grid-cols-4 gap-3 w-full max-w-md opacity-20 pointer-events-none transition-opacity duration-300" id="ingredient-palette">
        <div data-type="beef" class="ingredient-source bg-red-900/60 p-3 rounded-xl flex flex-col items-center shadow-lg border border-red-700/30">
            <span class="text-2xl">ü•©</span> <span class="text-[10px] mt-1 uppercase">Beef</span>
        </div>
        <div data-type="shrimp" class="ingredient-source bg-orange-900/60 p-3 rounded-xl flex flex-col items-center shadow-lg border border-orange-700/30">
            <span class="text-2xl">üç§</span> <span class="text-[10px] mt-1 uppercase">Shrimp</span>
        </div>
        <div data-type="bokchoy" class="ingredient-source bg-green-900/60 p-3 rounded-xl flex flex-col items-center shadow-lg border border-green-700/30">
            <span class="text-2xl">ü•¨</span> <span class="text-[10px] mt-1 uppercase">Veggie</span>
        </div>
        <div data-type="mushroom" class="ingredient-source bg-stone-800/60 p-3 rounded-xl flex flex-col items-center shadow-lg border border-stone-700/30">
            <span class="text-2xl">üçÑ</span> <span class="text-[10px] mt-1 uppercase">Shroom</span>
        </div>
    </div>

    <div id="drag-proxy" class="drag-proxy"></div>

    <div id="game-over" class="overlay">
        <h2 class="text-4xl text-yellow-500 mb-2 font-bold">FEAST ENDED</h2>
        <p class="text-red-200 mb-2" id="over-msg">You forgot the secret recipe...</p>
        <p class="text-sm text-gray-400 uppercase tracking-widest">Level Reached</p>
        <p class="text-3xl font-bold text-white mb-4" id="final-level">1</p>
        <p class="text-sm text-gray-400 uppercase tracking-widest">Total Score</p>
        <p class="text-5xl font-bold text-white mb-8" id="final-score">0</p>
        
        <div class="flex flex-col gap-3 w-full max-w-[200px]">
            <button id="restart-btn" class="bg-yellow-600 hover:bg-yellow-500 text-white px-10 py-3 rounded-full font-bold shadow-xl transition-all active:scale-95">
                TRY AGAIN
            </button>
            <button id="home-btn" class="bg-gray-700 hover:bg-gray-600 text-white px-10 py-3 rounded-full font-bold shadow-xl transition-all active:scale-95">
                HOME
            </button>
        </div>
    </div>

    <div id="feedback" class="fixed top-1/2 text-2xl font-bold pointer-events-none transition-all duration-500 opacity-0 z-50"></div>

    <script>
        const potArea = document.getElementById('pot-area');
        const mainPot = document.getElementById('main-pot');
        const levelEl = document.getElementById('level');
        const timerEl = document.getElementById('level-timer');
        const livesEl = document.getElementById('lives');
        const feedbackEl = document.getElementById('feedback');
        const dragProxy = document.getElementById('drag-proxy');
        const palette = document.getElementById('ingredient-palette');
        const memoryOverlay = document.getElementById('memory-phase');
        const phaseLabel = document.getElementById('phase-label');
        const gameOverOverlay = document.getElementById('game-over');
        const homeScreen = document.getElementById('home-screen');
        const streamControls = document.getElementById('stream-controls');
        const dualControls = document.getElementById('dual-controls');
        const streamDisplayArea = document.getElementById('stream-display-area');
        const streamTimerBar = document.getElementById('stream-countdown');
        const streamTimerFill = document.getElementById('stream-countdown-fill');
        
        let score = 0;
        let lives = 3;
        let level = 1;
        let activeIngredients = [];
        let gameActive = false;
        
        let gameMode = 'classic'; 
        let recipeHistory = [];
        let targetRecipe = { spicy: [], clear: [], tomato: [] }; 
        let nBackValue = 1; 
        
        // Stream / Dual N-Back Variables
        let streamHistoryVisual = [];
        let streamHistoryAudio = [];
        let streamIndex = 0;
        let streamTimer = null;
        let currentSkewerEl = null; 
        let currentTurnMatches = { visual: false, audio: false };
        let userResponses = { visual: false, audio: false };
        
        let ingredientsToCookThisRound = 0;
        let timeLeft = 0;
        let levelTimerInterval = null;

        const TYPES = {
            beef: { emoji: 'ü•©', time: 5000, points: 100, name: 'Beef' },
            shrimp: { emoji: 'üç§', time: 7000, points: 150, name: 'Shrimp' },
            bokchoy: { emoji: 'ü•¨', time: 4000, points: 50, name: 'Veggie' },
            mushroom: { emoji: 'üçÑ', time: 9000, points: 200, name: 'Mushroom' }
        };

        function speak(text) {
            if (!window.speechSynthesis) return;
            const utter = new SpeechSynthesisUtterance(text);
            utter.rate = 1.3;
            utter.pitch = 1.1;
            utter.volume = 1.0;
            window.speechSynthesis.speak(utter);
        }

        function stopSpeaking() {
            if (window.speechSynthesis) window.speechSynthesis.cancel();
        }

        function updatePotLayout() {
            const isStream = gameMode === 'stream';
            const divCenter = document.getElementById('divider-center');
            const d0 = document.getElementById('div-0');
            const d120 = document.getElementById('div-120');
            const d240 = document.getElementById('div-240');
            const tomatoBox = document.getElementById('tomato-recipe-box');

            if (isStream) {
                mainPot.classList.remove('triple');
                divCenter.style.display = 'block';
                d0.style.display = 'none';
                d120.style.display = 'none';
                d240.style.display = 'none';
                return;
            }

            if (level >= 5) {
                mainPot.classList.add('triple');
                divCenter.style.display = 'none';
                d0.style.display = 'block';
                d120.style.display = 'block';
                d240.style.display = 'block';
                tomatoBox.classList.remove('hidden');
            } else {
                mainPot.classList.remove('triple');
                divCenter.style.display = 'block';
                d0.style.display = 'none';
                d120.style.display = 'none';
                d240.style.display = 'none';
                tomatoBox.classList.add('hidden');
            }
        }

        function resetGame(mode) {
            stopSpeaking();
            gameMode = mode || 'classic';
            score = 0;
            lives = 3;
            level = 1;
            nBackValue = 1;
            
            recipeHistory = [];
            clearInterval(levelTimerInterval);
            activeIngredients.forEach(ing => {
                if(ing.el && ing.el.parentNode) ing.el.parentNode.removeChild(ing.el);
            });
            activeIngredients = [];
            
            streamHistoryVisual = [];
            streamHistoryAudio = [];
            streamIndex = 0;
            clearTimeout(streamTimer);
            streamDisplayArea.innerHTML = '';
            currentSkewerEl = null;
            
            document.querySelectorAll('.used-stick').forEach(el => el.remove());

            // Reset Controls
            streamControls.style.display = 'none';
            dualControls.style.display = 'none';
            streamTimerBar.classList.add('hidden');

            levelEl.innerText = level;
            livesEl.innerText = '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è';
            gameOverOverlay.style.display = 'none';
            
            updatePotLayout();

            if (gameMode === 'stream') {
                palette.style.display = 'none';
                dualControls.style.display = 'flex';
                // Unlock audio context
                speak(''); 
                startStreamLevel();
            } else {
                palette.style.display = 'grid';
                startRound();
            }
        }
        
        function goHome() {
            gameActive = false;
            stopSpeaking();
            clearInterval(levelTimerInterval);
            clearTimeout(streamTimer);
            
            activeIngredients.forEach(ing => {
                if(ing.el) ing.el.remove();
            });
            activeIngredients = [];
            
            streamDisplayArea.innerHTML = '';
            document.querySelectorAll('.used-stick').forEach(el => el.remove());
            
            gameOverOverlay.style.display = 'none';
            memoryOverlay.style.display = 'none';
            homeScreen.style.display = 'flex';
            
            streamControls.style.display = 'none';
            dualControls.style.display = 'none';
            streamTimerBar.classList.add('hidden');
            palette.style.display = 'grid'; 
            palette.style.opacity = '0.2';
        }

        document.getElementById('restart-btn').onclick = () => resetGame(gameMode);
        document.getElementById('home-btn').onclick = goHome;
        document.getElementById('ingame-home-btn').onclick = goHome;
        document.getElementById('ingame-restart-btn').onclick = () => resetGame(gameMode);

        document.getElementById('start-classic-btn').onclick = () => {
            homeScreen.style.display = 'none';
            resetGame('classic');
            requestAnimationFrame(updateGame);
        };

        document.getElementById('start-nback-btn').onclick = () => {
            homeScreen.style.display = 'none';
            resetGame('nback');
            requestAnimationFrame(updateGame);
        };
        
        document.getElementById('start-stream-btn').onclick = () => {
            homeScreen.style.display = 'none';
            resetGame('stream');
        };

        // --- STREAM / DUAL N-BACK LOGIC ---

        function startStreamLevel() {
            gameActive = true;
            streamHistoryVisual = [];
            streamHistoryAudio = [];
            streamIndex = 0;
            streamDisplayArea.innerHTML = '';
            currentSkewerEl = null;
            
            document.querySelectorAll('.used-stick').forEach(el => el.remove());
            
            nBackValue = level;
            
            const nText = nBackValue === 1 ? '1-BACK' : `${nBackValue}-BACK`;
            phaseLabel.innerText = `DUAL STREAM: ${nText}`;
            showFeedback(`LEVEL ${level}: ${nText}`, 'text-yellow-400');
            
            timerEl.innerText = "--";
            
            setTimeout(nextStreamTurn, 1500);
        }

        function createSkewer(emoji) {
            const container = document.createElement('div');
            container.className = 'skewer-wrapper';
            
            const stick = document.createElement('div');
            stick.className = 'skewer-stick';
            
            const emo = document.createElement('div');
            emo.className = 'skewer-emoji';
            emo.innerText = emoji;
            
            container.appendChild(emo);
            container.appendChild(stick);
            return container;
        }

        function nextStreamTurn() {
            if (!gameActive) return;

            // Evaluate previous turn if it wasn't the first item
            // Logic handled at end of turn below, this is start of new turn.

            if (streamIndex > 12 + (level * 2)) {
                level++;
                showFeedback("LEVEL COMPLETE!", "text-green-400");
                clearInterval(levelTimerInterval);
                setTimeout(startStreamLevel, 2000);
                return;
            }

            streamIndex++;
            userResponses = { visual: false, audio: false };
            
            // Reset button styles
            document.getElementById('btn-visual-match').classList.remove('clicked');
            document.getElementById('btn-audio-match').classList.remove('clicked');

            const keys = Object.keys(TYPES);
            let nextVisual, nextAudio;
            
            // Determine Matches Probability
            const canMatch = streamHistoryVisual.length >= nBackValue;
            const forceVisual = canMatch && Math.random() < 0.35;
            const forceAudio = canMatch && Math.random() < 0.35;

            // Visual Generation
            if (forceVisual) {
                nextVisual = streamHistoryVisual[streamHistoryVisual.length - nBackValue];
            } else {
                nextVisual = keys[Math.floor(Math.random() * keys.length)];
                // Avoid accidental match if not forced? 
                // Actually random matches are fair game in N-Back
            }

            // Audio Generation
            if (forceAudio) {
                nextAudio = streamHistoryAudio[streamHistoryAudio.length - nBackValue];
            } else {
                nextAudio = keys[Math.floor(Math.random() * keys.length)];
            }
            
            streamHistoryVisual.push(nextVisual);
            streamHistoryAudio.push(nextAudio);
            
            // Set Match Truth for this turn
            currentTurnMatches.visual = canMatch && (nextVisual === streamHistoryVisual[streamHistoryVisual.length - 1 - nBackValue]);
            currentTurnMatches.audio = canMatch && (nextAudio === streamHistoryAudio[streamHistoryAudio.length - 1 - nBackValue]);

            // VISUAL EXECUTION
            currentSkewerEl = createSkewer(TYPES[nextVisual].emoji);
            streamDisplayArea.appendChild(currentSkewerEl);
            currentSkewerEl.style.transform = "translate(-50%, 150%) scale(0.5)"; 
            requestAnimationFrame(() => {
                currentSkewerEl.style.transform = "translate(-50%, -50%) scale(1)"; 
            });

            // AUDIO EXECUTION
            speak(TYPES[nextAudio].name);

            // Turn State Info
            if (streamHistoryVisual.length <= nBackValue) {
                phaseLabel.innerText = `Memorize... (${streamHistoryVisual.length}/${nBackValue})`;
                phaseLabel.className = "text-xs text-blue-400 font-bold uppercase tracking-widest";
            } else {
                phaseLabel.innerText = `MATCH ${nBackValue}-BACK?`;
                phaseLabel.className = "text-xs text-yellow-400 font-bold uppercase tracking-widest animate-pulse";
            }

            // TIMER EXECUTION
            const turnDuration = Math.max(2500, 3500 - (level * 200));
            streamTimerBar.classList.remove('hidden');
            streamTimerFill.style.transition = 'none';
            streamTimerFill.style.width = '100%';
            streamTimerFill.offsetHeight; // Reflow
            streamTimerFill.style.transition = `width ${turnDuration}ms linear`;
            streamTimerFill.style.width = '0%';

            streamTimer = setTimeout(() => {
                resolveStreamTurn();
            }, turnDuration);
        }

        function resolveStreamTurn() {
            if (!gameActive) return;

            // Dip the skewer
            if (currentSkewerEl) {
                currentSkewerEl.classList.add('dipped');
                currentSkewerEl.classList.add('sunk');
                
                // Add stick to pot
                const stick = document.createElement('div');
                stick.className = 'used-stick';
                stick.style.left = (20 + Math.random() * 60) + '%';
                stick.style.top = (20 + Math.random() * 60) + '%';
                stick.style.transform = `rotate(${Math.random() * 360}deg)`;
                mainPot.appendChild(stick);
                setTimeout(() => { stick.style.opacity = '0'; setTimeout(() => stick.remove(), 1500); }, 2000);
            }

            // Don't score during memorization phase
            if (streamHistoryVisual.length > nBackValue) {
                // SCORING LOGIC - STRICT DUAL N-BACK
                // Both must be strictly correct to pass.
                
                // Correctness check: Match logic must align with user action
                const visualCorrect = (currentTurnMatches.visual === userResponses.visual);
                const audioCorrect = (currentTurnMatches.audio === userResponses.audio);

                if (visualCorrect && audioCorrect) {
                    // Success!
                    let pointsEarned = 0;
                    if (currentTurnMatches.visual) pointsEarned += 200; // Bonus for Hit
                    if (currentTurnMatches.audio) pointsEarned += 200; // Bonus for Hit
                    
                    if (pointsEarned > 0) {
                        score += pointsEarned;
                        showFeedback("MATCH!", "text-green-400");
                    }
                    // If no matches were present and user did nothing, it's a correct rejection (safe, no points)
                } else {
                    // Failure: At least one modality was wrong
                    loseLife();
                    
                    let msg = "MISS!";
                    if (!visualCorrect && !audioCorrect) {
                        msg = "TOTAL FAIL!";
                    } else if (!visualCorrect) {
                        msg = "VISUAL WRONG!";
                    } else if (!audioCorrect) {
                        msg = "AUDIO WRONG!";
                    }
                    
                    showFeedback(msg, "text-red-600");
                }
            }

            setTimeout(nextStreamTurn, 300);
        }

        // Button Handlers for Dual Mode
        document.getElementById('btn-visual-match').onclick = function() {
            if (!gameActive || streamHistoryVisual.length <= nBackValue) return;
            userResponses.visual = true;
            this.classList.add('clicked');
        };

        document.getElementById('btn-audio-match').onclick = function() {
            if (!gameActive || streamHistoryVisual.length <= nBackValue) return;
            userResponses.audio = true;
            this.classList.add('clicked');
        };

        // --- CLASSIC / N-BACK LOGIC ---

        function generateRecipe() {
            const count = Math.min(2 + Math.floor(level / 2), 6);
            const types = Object.keys(TYPES);
            const recipe = { spicy: [], clear: [], tomato: [] };

            for (let i = 0; i < count; i++) {
                recipe.spicy.push(types[Math.floor(Math.random() * types.length)]);
                recipe.clear.push(types[Math.floor(Math.random() * types.length)]);
                if (level >= 5) {
                    recipe.tomato.push(types[Math.floor(Math.random() * types.length)]);
                }
            }
            return recipe;
        }

        function startRound() {
            gameActive = false;
            updatePotLayout();
            
            const newRecipe = generateRecipe();
            recipeHistory.push(newRecipe);

            if (gameMode === 'nback' && level > 1) {
                targetRecipe = recipeHistory[recipeHistory.length - 2];
                document.getElementById('nback-hint').classList.remove('hidden');
                document.getElementById('memory-title').innerText = "MEMORIZE FOR NEXT!";
            } else {
                targetRecipe = newRecipe;
                document.getElementById('nback-hint').classList.add('hidden');
                document.getElementById('memory-title').innerText = "MEMORIZE THE SIDES";
            }

            document.getElementById('round-num').innerText = level;
            const spicyList = document.getElementById('spicy-recipe-list');
            const clearList = document.getElementById('clear-recipe-list');
            const tomatoList = document.getElementById('tomato-recipe-list');

            spicyList.innerHTML = newRecipe.spicy.map(t => TYPES[t].emoji).join(' ');
            clearList.innerHTML = newRecipe.clear.map(t => TYPES[t].emoji).join(' ');
            tomatoList.innerHTML = newRecipe.tomato.map(t => TYPES[t].emoji).join(' ');

            memoryOverlay.style.display = 'flex';
            palette.style.opacity = "0.2";
            palette.style.pointerEvents = "none";
            phaseLabel.innerText = "Memorizing...";

            const memDuration = Math.max(2000, 6000 - (level * 250));
            const timerBar = document.getElementById('memory-timer-bar');
            timerBar.style.transition = 'none';
            timerBar.style.width = '100%';
            
            setTimeout(() => {
                timerBar.style.transition = `width ${memDuration}ms linear`;
                timerBar.style.width = '0%';
            }, 50);

            setTimeout(() => {
                memoryOverlay.style.display = 'none';
                startCookingPhase();
            }, memDuration);
        }

        function startCookingPhase() {
            gameActive = true;
            phaseLabel.innerText = gameMode === 'nback' ? `COOK PREVIOUS ROUND!` : "Cook the Recipe!";
            phaseLabel.className = "text-xs text-yellow-400 font-bold uppercase tracking-widest animate-pulse";
            palette.style.opacity = "1";
            palette.style.pointerEvents = "auto";

            ingredientsToCookThisRound = targetRecipe.spicy.length + targetRecipe.clear.length + targetRecipe.tomato.length;
            timeLeft = 30 + (level * 2);
            timerEl.innerText = timeLeft;

            levelTimerInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft < 10 ? `0${timeLeft}` : timeLeft;
                if (timeLeft <= 0) {
                    loseLife("Time ran out!");
                }
            }, 1000);
        }

        // --- DRAG AND DROP ---

        let dragData = null;
        palette.addEventListener('touchstart', handleDragStart, {passive: false});
        palette.addEventListener('mousedown', handleDragStart);

        function handleDragStart(e) {
            const source = e.target.closest('.ingredient-source');
            if (!source || !gameActive) return;

            const type = source.dataset.type;
            dragData = { type };

            dragProxy.innerText = TYPES[type].emoji;
            dragProxy.style.display = 'block';
            updateProxyPos(e);

            window.addEventListener('touchmove', handleDragMove, {passive: false});
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchend', handleDragEnd);
            window.addEventListener('mouseup', handleDragEnd);
            
            if (e.cancelable) e.preventDefault();
        }

        function handleDragMove(e) {
            if (!dragData) return;
            updateProxyPos(e);
            if (e.cancelable) e.preventDefault();
        }

        function updateProxyPos(e) {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            dragProxy.style.left = `${x - 20}px`;
            dragProxy.style.top = `${y - 20}px`;
        }

        function handleDragEnd(e) {
            if (!dragData) return;

            const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const y = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            const potRect = mainPot.getBoundingClientRect();
            const centerX = potRect.left + potRect.width / 2;
            const centerY = potRect.top + potRect.height / 2;
            const dist = Math.hypot(x - centerX, y - centerY);

            if (dist < potRect.width / 2 - 20) {
                const angle = (Math.atan2(y - centerY, x - centerX) * 180 / Math.PI + 360) % 360;
                let side = 'spicy';

                if (level >= 5) {
                    if (angle > 300 || angle <= 60) side = 'clear';
                    else if (angle > 60 && angle <= 180) side = 'tomato';
                    else side = 'spicy';
                } else {
                    side = (angle > 90 && angle < 270) ? 'spicy' : 'clear';
                }

                addIngredient(dragData.type, x - potRect.left, y - potRect.top, side);
            }

            dragData = null;
            dragProxy.style.display = 'none';
            window.removeEventListener('touchmove', handleDragMove);
            window.removeEventListener('mousemove', handleDragMove);
            window.removeEventListener('touchend', handleDragEnd);
            window.removeEventListener('mouseup', handleDragEnd);
        }

        function addIngredient(type, x, y, side) {
            const el = document.createElement('div');
            el.className = 'ingredient';
            el.style.left = `${x - 20}px`;
            el.style.top = `${y - 20}px`;
            
            const icon = document.createElement('span');
            icon.className = 'ingredient-icon';
            icon.innerText = TYPES[type].emoji;
            
            const timer = document.createElement('div');
            timer.className = 'cooking-timer';
            timer.innerText = 'RAW';
            
            el.appendChild(icon);
            el.appendChild(timer);
            mainPot.appendChild(el);

            const ing = {
                type, side, el, timer, 
                startTime: Date.now(),
                targetTime: TYPES[type].time,
                state: 'raw'
            };

            el.onclick = () => harvest(ing);
            activeIngredients.push(ing);
        }

        function harvest(ing) {
            if (!gameActive) return;
            
            const idx = activeIngredients.indexOf(ing);
            if (idx > -1) activeIngredients.splice(idx, 1);
            
            const recipeList = targetRecipe[ing.side];
            const recipeIdx = recipeList.indexOf(ing.type);

            if (recipeIdx === -1) {
                showFeedback("WRONG SIDE!", "text-red-500");
                loseLife("Wrong ingredient for this broth!");
            } else if (ing.state === 'perfect') {
                recipeList.splice(recipeIdx, 1);
                score += TYPES[ing.type].points;
                ingredientsToCookThisRound--;
                showFeedback("PERFECT!", "text-green-400");
                if (ingredientsToCookThisRound === 0) finishRound();
            } else {
                showFeedback(ing.state.toUpperCase() + "!", "text-orange-400");
                loseLife("It wasn't cooked perfectly!");
            }
            
            ing.el.style.transform = "scale(0) translateY(-50px)";
            ing.el.style.opacity = "0";
            setTimeout(() => ing.el.remove(), 300);
        }

        function updateGame() {
            if (!gameActive) {
                requestAnimationFrame(updateGame);
                return;
            }

            const now = Date.now();
            activeIngredients.forEach(ing => {
                const elapsed = now - ing.startTime;
                const ratio = elapsed / ing.targetTime;

                if (ratio < 0.8) {
                    ing.state = 'raw';
                    ing.timer.innerText = 'RAW';
                } else if (ratio < 1.2) {
                    ing.state = 'perfect';
                    ing.timer.innerText = 'PERFECT!';
                    ing.timer.style.color = '#4ade80';
                    ing.el.style.transform = `scale(${1 + Math.sin(now/100)*0.05})`;
                } else if (ratio < 1.6) {
                    ing.state = 'overcooked';
                    ing.timer.innerText = 'OVER';
                    ing.timer.style.color = '#f87171';
                } else {
                    ing.state = 'burnt';
                    ing.timer.innerText = 'BURNT';
                    ing.el.style.filter = 'grayscale(1) brightness(0.2)';
                }
            });

            if (Math.random() < 0.1) createSteam();
            requestAnimationFrame(updateGame);
        }

        function createSteam() {
            const s = document.createElement('div');
            s.className = 'steam';
            const size = 20 + Math.random() * 40;
            s.style.width = s.style.height = `${size}px`;
            s.style.left = `${Math.random() * 80 + 10}%`;
            s.style.top = `${Math.random() * 80 + 10}%`;
            mainPot.appendChild(s);
            setTimeout(() => s.remove(), 2500);
        }

        function showFeedback(text, colorClass) {
            feedbackEl.innerText = text;
            feedbackEl.className = `fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-bold pointer-events-none transition-all duration-500 z-50 ${colorClass}`;
            feedbackEl.style.opacity = '1';
            feedbackEl.style.transform = 'translate(-50%, -100%) scale(1.2)';
            
            setTimeout(() => {
                feedbackEl.style.opacity = '0';
                feedbackEl.style.transform = 'translate(-50%, -150%) scale(1)';
            }, 600);
        }

        function loseLife(reason) {
            lives--;
            livesEl.innerText = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);
            
            if (lives <= 0) {
                endGame(reason || "Out of lives!");
            }
        }

        function finishRound() {
            gameActive = false;
            clearInterval(levelTimerInterval);
            level++;
            levelEl.innerText = level;
            showFeedback("ROUND CLEAR!", "text-yellow-400");
            setTimeout(startRound, 1500);
        }

        function endGame(msg) {
            gameActive = false;
            clearInterval(levelTimerInterval);
            clearTimeout(streamTimer);
            document.getElementById('over-msg').innerText = msg;
            document.getElementById('final-level').innerText = level;
            document.getElementById('final-score').innerText = score;
            gameOverOverlay.style.display = 'flex';
        }

        updatePotLayout();
        // Kick off the loop
        requestAnimationFrame(updateGame);
    </script>
</body>
</html>
